# InMemoryServerClient - Copilotインストラクション

## 重要: 対話言語について
AIとのすべてのやり取りは日本語で行います。説明、コメント、ドキュメンテーションは日本語で記述してください。コードは英語（C#）で記述してください。コード中のコメントも英語で記述します。

## プロジェクト概要
このプロジェクトは、C#でインメモリステートフルサーバーとCLIクライアントを実装します。サーバーはメモリ内に状態を保持し、クライアントがこの状態と対話するためのインターフェースを提供します。クライアントはコマンドラインインターフェースで、サーバーに接続してユーザーがサーバーの状態を操作できるようにします。

このプロジェクトの目的は、軽量で高速なインメモリデータ処理システムを提供し、分散アプリケーションのプロトタイピングや小規模なデータ処理タスクに適した環境を実現することです。本番環境での使用も視野に入れ、拡張性とスケーラビリティを考慮した設計を行います。

初期実装はC#で行いますが、将来的にGoでの実装も検討しています。このため、リポジトリ構造は両方の言語での実装をサポートできるように設計されています。

## アーキテクチャ

### サーバー
- メモリ内にデータを保持するステートフルサーバーを実装
- 通信には主にWebSocketを使用し、後にgRPC (MagicOnion)も選択できるよう抽象化する
- 複数の同時クライアント接続をサポート
- 必要に応じて状態を保存するクリーンなシャットダウンプロセスを含める
- クライアントリクエスト処理にコマンドパターンを実装
- 適切なエラー処理とロギングを含める

### クライアント
- コマンドラインインターフェース（CLI）クライアントの実装
- サーバーへの接続管理をサポート（接続先URLを設定可能）
- サーバー状態を操作するための直感的なコマンドを提供
- ヘルプコマンドとドキュメントを含める
- ネットワーク問題に対する適切なエラー処理を実装

## コードスタイルと実践

- C#のコーディング規約とベストプラクティスに従う
- すべてのI/O操作にasync/awaitを使用
- 適切な例外処理を実装
- 公開APIにはXMLドキュメントコメントを含める
- 変更後にビルドを実行して、コード品質を確保する。`dotnet build`を使用してソリューションをコンパイルする
- サーバーとクライアントの両方のコンポーネントに対するユニットテストを作成する。`dotnet test`を使用してテストを実行する
- 適切な場所で依存性注入を使用
- SOLIDの原則に従う

## プロジェクト構造

リポジトリはC#とGoの両方の実装をサポートする構造になっています：

サーバーとクライアントの両方で実装を切り替えられるように抽象化を行い、通信プロトコル（WebSocketとgRPC）を選択できるようにします。

### C#実装 (`/csharp` ディレクトリ)
- ソリューションを明確なプロジェクトに分ける：
  - `InMemoryServer` - サーバー実装
  - `CliClient` - コマンドラインクライアント
  - `Shared` - 共有コード、モデル、インターフェース
  - `Tests` - ユニットテストと統合テスト
  - `Dockerfile` - サーバーのコンテナ化用

### Go実装 (`/go` ディレクトリ・将来的に実装予定)
- 標準的なGoプロジェクト構造に従う：
  - `server` - サーバー実装
  - `client` - クライアントCLI実装
  - `pkg` - 共有パッケージ
  - テストは各実装ファイルと同じディレクトリに `_test.go` として配置
  - `Dockerfile` - サーバーのコンテナ化用

## 実装する機能

1. サーバー：
   - CRUD操作を備えたインメモリデータストレージ
   - JWT（JSON Web Token）を使用した認証メカニズム
   - コマンド処理パイプライン
   - 状態の永続化（オプション）
   - ヘルスチェックエンドポイント
   - グレースフルシャットダウン機能   - クライアントグループ管理機能：
     - UUIDv4で識別されるグループの作成と管理
     - クライアントからのグループ名指定をサポート
     - グループに所属するクライアント間のメッセージブロードキャスト
     - グループの自動割り当て（クライアントが指定しない場合）
     - グループ一覧確認用API
     - グループの寿命管理（作成から10分で自動消去）
     - グループあたりの最大接続数制限（1グループ最大5セッション）

2. クライアント：
   - インタラクティブコマンドモード
   - バッチコマンドモード
   - 接続管理
     - 接続先URLを環境変数やコマンドライン引数で設定可能にする
     - 接続時のグループ名指定機能
   - グループ操作機能
     - グループ一覧の取得
     - グループ内メッセージ送信
     - 現在所属しているグループの確認
   - 結果の美しい表示
   - コマンド履歴
   - タブ補完機能（オプション）

## データモデルと通信プロトコル
- データモデルは基本的なキーバリューストアから始め、必要に応じて構造化データをサポート
- 通信プロトコルはJSONベースで、将来的にはバイナリプロトコルもサポート可能な設計にする
- 主な操作例：
  - `GET key` - キーに対応する値を取得
  - `SET key value` - キーと値のペアを保存
  - `DELETE key` - キーと対応する値を削除
  - `LIST [pattern]` - パターンに一致するキーのリストを取得
  - `WATCH key` - キーの変更を監視
  - `JOIN group_name` - 指定したグループに参加（グループが最大接続数に達している場合はエラー）
  - `BROADCAST message` - 所属グループ内の全クライアントにメッセージを送信
  - `GROUPS` - 利用可能なグループ一覧を取得
  - `MYGROUP` - 現在所属しているグループ情報を取得

## セキュリティ考慮事項
- JWT（JSON Web Token）を使用した認証と認可のメカニズムを実装
- 通信の暗号化をサポート
- 入力バリデーションを徹底し、インジェクション攻撃などを防止
- 適切なレート制限を実装して、DoS攻撃を緩和
- HTTPSへの対応はフロントにLBやプロキシを配置してTLSターミネーションする設計を考慮

## 技術スタック
### C#実装
- .NET 9以上
- C# 13以上
- CLIパーシング用のConsoleAppFramework
- JWT認証用のSystem.IdentityModel.Tokens.Jwt
- サーバーにはMicrosoft.Extensions.Hostingの使用を検討
- 設定管理にはIConfiguration/IOptionsパターンを使用し、appsettings.jsonと環境変数の両方をサポート
- WebSocket通信用のSystem.Net.WebSockets
- 後々のgRPC対応にMagicOnionを検討

### Go実装（将来）
- Go 1.21以上
- CLIパーシング用のCobra
- 設定管理にはViperライブラリを使用（YAML/JSON設定ファイルと環境変数の両方をサポート）
- JWT認証用のjwt-go
- WebSocket通信用のgorilla/websocket
- gRPC用の標準ライブラリとprotobuf

## 開発ガイドライン
- クリーンで読みやすく保守しやすいコードを書く
- 適切なコメントを含める
- インメモリ状態のパフォーマンスへの影響を考慮する
- 拡張性を考慮した設計
- 適切なロギングを実装する
- サーバーのスレッドセーフティを考慮する
- エラー処理のガイドライン：
  - 意味のある例外クラスを定義する
  - 例外メッセージは具体的かつ有用な情報を含める
  - クライアントに返すエラーは適切に抽象化する
  - ログには詳細なエラー情報を記録する

## コンテナ化
- サーバーはDockerコンテナとして実行できるようにDockerfileを提供
- マルチステージビルドを使用して最終イメージのサイズを最小化
- 環境変数による設定の注入をサポート
  - 特に接続先URLは環境変数やコマンドライン引数で変更可能にし、コンテナイメージを再ビルドせずに異なる環境で使用できるようにする
- コンテナ内で適切な権限で実行（rootユーザー以外）
- ヘルスチェックエンドポイントの設定
- Dockerイメージをビルドおよび実行するためのコマンド例をドキュメントに含める
- Docker Composeファイルを提供して、開発環境でのサービス起動を容易にする（オプション）

## CI/CD
- GitHub Actionsを使用してCI/CDパイプラインを構築
- CIワークフロー（PRとメインブランチへのプッシュ時に実行）:
  - ソースコードのビルド（リリースビルド構成を使用）
  - テストの実行
  - Dockerイメージのビルド（ビルドのみで、プッシュは行わない）
  - コードスタイルとフォーマットのチェック
- CDワークフロー（タグプッシュ時に実行）:
  - ソースコードのビルドとテスト
  - Dockerイメージのビルドとタグ付け
  - Docker Hubへのイメージのプッシュ
  - リリースノートの自動生成
- バージョン管理はセマンティックバージョニングを採用
- 複数プラットフォーム（AMD64、ARM64）対応のビルドを考慮
- 機密情報はGitHub Secretsを使用して管理

## ドキュメント
- コードにはXMLドキュメントコメントを付ける
- READMEには、インストール手順、基本的な使用方法、設定オプションを含める
- コマンドリファレンスドキュメントを作成する
- API仕様書を作成する（通信プロトコルの詳細を含む）

## テスト
- サーバーコマンドハンドラーのユニットテスト
- クライアントコマンドパーシングのユニットテスト
- サーバー-クライアント通信の統合テスト
- 同時接続のロードテスト（オプション）

コードを生成する際は、サーバーとクライアントの両方のコンポーネントが構造化され、最新のC#プラクティスに従い、適切なエラー処理とドキュメントを含むようにしてください。
