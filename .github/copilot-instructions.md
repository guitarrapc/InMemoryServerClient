# InMemoryServerClient - Copilotインストラクション

## 最重要ルール - 新しいルールの追加

ユーザーから今回限りではなく常に対応が必要と考えられる指示を受けた場合

1. 「これを標準のルールにしますか?」と質問する
2. YESの回答を得た場合、`.github/copilot-instructions.md`にルールを追加する
3. 以降は標準ルールとして常に適用する

このプロセスにより、プロジェクトのルールを継続的に改善していきます。

## 重要: 対話言語について
AIとのすべてのやり取りは日本語で行います。説明、コメント、ドキュメンテーションは日本語で記述してください。コードは英語（C#）で記述してください。コード中のコメントも英語で記述します。

## プロジェクト概要
このプロジェクトは、C#でインメモリステートフルサーバーとCLIクライアントを実装します。サーバーはメモリ内に状態を保持し、クライアントがこの状態と対話するためのインターフェースを提供します。クライアントはコマンドラインインターフェースで、サーバーに接続してユーザーがサーバーの状態を操作できるようにします。

このプロジェクトの目的は、軽量で高速なインメモリデータ処理システムを提供し、分散アプリケーションのプロトタイピングや小規模なデータ処理タスクに適した環境を実現することです。本番環境での使用も視野に入れ、拡張性とスケーラビリティを考慮した設計を行います。

初期実装はC#で行いますが、将来的にGoでの実装も検討しています。このため、リポジトリ構造は両方の言語での実装をサポートできるように設計されています。

## アーキテクチャ

### サーバー
- メモリ内にデータを保持するステートフルサーバーを実装
- 通信には主にWebSocketを使用し、後にgRPC (MagicOnion)も選択できるよう抽象化する
- 複数の同時クライアント接続をサポート
- 必要に応じて状態を保存するクリーンなシャットダウンプロセスを含める
- クライアントリクエスト処理にコマンドパターンを実装
- 適切なエラー処理とロギングを含める

### クライアント
- コマンドラインインターフェース（CLI）クライアントの実装
- サーバーへの接続管理をサポート（接続先URLを設定可能）
- サーバー状態を操作するための直感的なコマンドを提供
- ヘルプコマンドとドキュメントを含める
- ネットワーク問題に対する適切なエラー処理を実装

## プロジェクト構造

リポジトリはC#とGoの両方の実装をサポートする構造になっています：

サーバーとクライアントの両方で実装を切り替えられるように抽象化を行い、通信プロトコル（WebSocketとgRPC）を選択できるようにします。

### C#実装 (`/csharp` ディレクトリ)
- ソリューションを明確なプロジェクトに分ける：
  - `InMemoryServer` - サーバー実装
  - `CliClient` - コマンドラインクライアント
  - `Shared` - 共有コード、モデル、インターフェース
  - `Tests` - ユニットテストと統合テスト
  - `Dockerfile` - サーバーのコンテナ化用

### Go実装 (`/go` ディレクトリ・将来的に実装予定)
- 標準的なGoプロジェクト構造に従う：
  - `server` - サーバー実装
  - `client` - クライアントCLI実装
  - `pkg` - 共有パッケージ
  - テストは各実装ファイルと同じディレクトリに `_test.go` として配置
  - `Dockerfile` - サーバーのコンテナ化用

## 実装する機能

1. サーバー：
   - CRUD操作を備えたインメモリデータストレージ
   - JWT（JSON Web Token）を使用した認証メカニズム
   - コマンド処理パイプライン
   - 状態の永続化（オプション）
   - ヘルスチェックエンドポイント
   - グレースフルシャットダウン機能
   - サーバーステータス機能：
     - サーバー起動時間の追跡
     - 接続中のクライアント数の監視
     - 有効なグループ数とその詳細情報の提供
     - 各グループの接続クライアント数
     - 現在進行中のバトル数と状態
     - システムリソース使用状況（メモリ使用量、CPU使用率）
   - クライアントグループ管理機能：
     - UUIDv4で識別されるグループの作成と管理
     - クライアントからのグループ名指定をサポート
     - グループに所属するクライアント間のメッセージブロードキャスト
     - グループの自動割り当て（クライアントが指定しない場合）
     - グループ一覧確認用API
     - グループの寿命管理（作成から10分で自動消去）
     - グループあたりの最大接続数制限（1グループ最大5セッション）
     - バトルシステム機能：
        - グループが満員（5セッション）になった時の自動バトル開始
        - 20x20サイズの疑似フィールド生成
        - ランダムな敵配置アルゴリズム（10〜15体程度の敵を配置）
        - 完全オートバトルのターン制RPG風バトルシステム
            - エンティティ（プレイヤー・敵）の基本ステータス：HP(100〜300)、攻撃力(10〜30)、防御力(5〜15)、移動速度(1〜3)
            - 可能な行動：移動、攻撃、防御のみ
            - 敵はHPに応じて3種類（小型：HP100、中型：HP200、大型：HP300）
            - プレイヤーはHP200で固定、他のステータスはランダム割り当て
            - 攻撃は隣接マスのエンティティにのみ可能
            - 防御時は次のターンまで被ダメージを50%軽減
            - 各エンティティは自律的に最適行動を選択
            - 勝利条件：全ての敵の撃破
            - 敗北条件：全プレイヤーのHP0
        - 100〜300ターン程度で完了するバランス調整
        - バトルの事前計算とクライアント再生方式：
            - サーバーはクライアントが5つ揃うまで待機
            - クライアントが5つ揃うとサーバーはクライアント全員に「接続が揃った」ことを通知
            - サーバーは全クライアントから「接続揃い確認」応答を受け取ったことを確認
            - 全クライアントからの確認後、サーバーはバトル開始を通知
            - サーバーはバトルフィールドを作成し、バトル決着まで高速に事前演算
            - 演算完了後、サーバーはバトル結果をJSONL形式でローカル保存
            - サーバーは事前演算結果を各クライアントにブロードキャスト
            - クライアントは受け取った事前演算結果を5fps相当の速度で再生
            - 再生完了後、クライアントはサーバーとの接続を切断
        - 1セッション = 1プレイヤーのマッピング
        - バトル結果のJSON LINE形式でのローカル保存（./battle_replay/）

2. クライアント：
   - インタラクティブコマンドモード
      - サーバーに対してコマンドを入力し、リアルタイムで応答を受け取るモード
      - ユーザーがコマンドを入力すると、サーバーにリクエストを送信し、結果を表示
      - ユーザーがコマンド履歴を参照できるようにする
   - バッチコマンドモード
      - サーバーに対して5セッションをまとめて接続し、バトルを開始するためのコマンド
   - 接続管理
     - 接続先URLを環境変数やコマンドライン引数で設定可能にする
     - 接続時のグループ名指定機能
     - まとめてN個のクライアントとして接続する機能 (デフォルト1)
        - 1クライアントを使って、サーバーに5セッションまとめて接続してバトルを開始させるために利用する
     - グループ操作機能
        - グループ一覧の取得
        - グループ内メッセージ送信
        - 現在所属しているグループの確認
     - バトル操作機能
        - バトル状態の表示（フィールド状況、各エンティティのHP・位置など）
        - バトル進行状況の監視
        - バトルログの表示
        - 自分のキャラクターのステータス確認
        - リプレイファイルの閲覧
        - 再生完了通知の送信
     - サーバーステータス確認機能
        - サーバー起動時間の表示
        - 接続中のクライアント数の表示
        - グループ一覧と各グループのクライアント数の表示
        - 現在進行中のバトル情報の表示
        - サーバーリソース使用状況の表示
   - 結果の美しい表示
   - コマンド履歴

## データモデルと通信プロトコル
- データモデルは基本的なキーバリューストアから始め、必要に応じて構造化データをサポート
- 通信プロトコルはJSONベースで、将来的にはバイナリプロトコルもサポート可能な設計にする
- 主な操作例：
  - `GET key` - キーに対応する値を取得
  - `SET key value` - キーと値のペアを保存
  - `DELETE key` - キーと対応する値を削除
  - `LIST [pattern]` - パターンに一致するキーのリストを取得
  - `WATCH key` - キーの変更を監視  - `JOIN group_name` - 指定したグループに参加（グループが最大接続数に達している場合はエラー）
  - `BROADCAST message` - 所属グループ内の全クライアントにメッセージを送信
  - `GROUPS` - 利用可能なグループ一覧を取得
  - `MYGROUP` - 現在所属しているグループ情報を取得
  - `BATTLE_STATUS` - 現在進行中のバトルの状態を取得
  - `BATTLE_ACTION action_type [params]` - バトル中のプレイヤーアクション指定（移動、攻撃など）
  - `BATTLE_REPLAY battle_id` - 指定したバトルのリプレイデータを取得
  - `BATTLE_COMPLETE` - バトルの再生完了をサーバーに通知
  - `SERVER_STATUS` - サーバーの全体的な状態情報を取得

## セキュリティ考慮事項
- JWT（JSON Web Token）を使用した認証と認可のメカニズムを実装
- 通信の暗号化をサポート
- 入力バリデーションを徹底し、インジェクション攻撃などを防止
- 適切なレート制限を実装して、DoS攻撃を緩和
- HTTPSへの対応はフロントにLBやプロキシを配置してTLSターミネーションする設計を考慮

## 技術スタック

### C#実装

C#の基礎的なルールは次の通り

- C#のコーディング規約とベストプラクティスに従う
- すべてのI/O操作にasync/awaitを使用
- 適切な例外処理を実装する
- 適切な場所で依存性注入を使用する
- SOLIDの原則に従う
- 公開APIにはXMLドキュメントコメントを含める
- 変更後にビルドを実行して、コード品質を確保する。`dotnet build`を使用してソリューションをコンパイルする
- サーバーとクライアントの両方のコンポーネントに対するユニットテストを作成する。コードの変更を行ったら、`dotnet test`を使用してテストを実行する
- コードの変更を行ったら、`dotnet format`を使用してコードスタイルを自動的に整形する
- .NET 9以上
- C# 13以上
- TreatWarningsAsErrorsを有効にして、警告をエラーとして扱います。すべての警告を解決することを目指します。
- Top Level Statementsを使用して、エントリポイントを簡潔に保ちます。

パフォーマンスの最大化のため、いかに注意します。

- 短寿命なオブジェクトにはstructを用いることができるか検討します。例えば`readonly ref struct`や`readonly struct`はパフォーマンス向上に寄与します。Mutable Structは意識的に避けます。
- 非同期メソッドは`async`/`await`を使用して、I/Oバウンド操作のパフォーマンスを向上させます。生`Task`メソッドを避けて、意識的に`async/await`パターンを使用します。
- 並列アクセスがあるコレクションは、スレッドセーフなコレクションを使用します。例えば、`ConcurrentDictionary<TKey, TValue>`や`ConcurrentBag<T>`などを利用します。

ライブラリやコーディングパターンは次の通りです

- サーバーはMinimal APIを使用して実装します。
- 設定管理にはIConfiguration/IOptionsパターンを使用し、appsettings.jsonと環境変数の両方をサポート
- CLIパーシングにConsoleAppFrameworkを用います。使い方は[こちら](https://github.com/Cysharp/ConsoleAppFramework)を参照します。
- JWT認証用に`System.IdentityModel.Tokens.Jwt`を用います。
- WebSocket通信用に[SignalR](https://github.com/SignalR/SignalR)を用います。
- 後々のgRPC対応にMagicOnionを検討します。
- ユニットテストに`xunit.v3`(xUnitのバージョン3)、モックに`NSubstirute`を用います。xunit.v3の使い方は[こちら](https://xunit.net/docs/getting-started/v3/whats-new)を参照します。

### Go実装（将来）
- Go 1.21以上
- CLIパーシング用のCobra
- 設定管理にはViperライブラリを使用（YAML/JSON設定ファイルと環境変数の両方をサポート）
- JWT認証用のjwt-go
- WebSocket通信用のgorilla/websocket
- gRPC用の標準ライブラリとprotobuf

## 開発ガイドライン
- クリーンで読みやすく保守しやすいコードを書く
- 適切なコメントを含める
- インメモリ状態のパフォーマンスへの影響を考慮する
- 拡張性を考慮した設計
- 適切なロギングを実装する
- サーバーのスレッドセーフティを考慮する
- エラー処理のガイドライン：
  - 意味のある例外クラスを定義する
  - 例外メッセージは具体的かつ有用な情報を含める
  - クライアントに返すエラーは適切に抽象化する
  - ログには詳細なエラー情報を記録する
- **バトルシステムバランス**: バトルシステムはプレイヤーが勝ちやすくなるようバランス調整する
  - プレイヤーのHP・攻撃力・防御力にボーナスを付与
  - 敵の数・HP・ステータスを適切に調整
  - プレイヤーの勝率を70-80%程度に維持

## コンテナ化
- サーバーはDockerコンテナとして実行できるようにDockerfileを提供
- マルチステージビルドを使用して最終イメージのサイズを最小化
- 環境変数による設定の注入をサポート
  - 特に接続先URLは環境変数やコマンドライン引数で変更可能にし、コンテナイメージを再ビルドせずに異なる環境で使用できるようにする
- コンテナ内で適切な権限で実行（rootユーザー以外）
- ヘルスチェックエンドポイントの設定
- Dockerイメージをビルドおよび実行するためのコマンド例をドキュメントに含める
- Docker Composeファイルを提供して、開発環境でのサービス起動を容易にする（オプション）

## CI/CD
- GitHub Actionsを使用してCI/CDパイプラインを構築
- CIワークフロー（PRとメインブランチへのプッシュ時に実行）:
  - ソースコードのビルド（リリースビルド構成を使用）
  - テストの実行
  - Dockerイメージのビルド（ビルドのみで、プッシュは行わない）
  - コードスタイルとフォーマットのチェック
- CDワークフロー（タグプッシュ時に実行）:
  - ソースコードのビルドとテスト
  - Dockerイメージのビルドとタグ付け
  - Docker Hubへのイメージのプッシュ
  - リリースノートの自動生成
- バージョン管理はセマンティックバージョニングを採用
- 複数プラットフォーム（AMD64、ARM64）対応のビルドを考慮
- 機密情報はGitHub Secretsを使用して管理

## ドキュメント
- コードにはXMLドキュメントコメントを付ける
- READMEには、インストール手順、基本的な使用方法、設定オプションを含める
- コマンドリファレンスドキュメントを作成する
- API仕様書を作成する（通信プロトコルの詳細を含む）

## テスト
- サーバーコマンドハンドラーのユニットテスト
- クライアントコマンドパーシングのユニットテスト
- サーバー-クライアント通信の統合テスト
- 同時接続のロードテスト（オプション）

コードを生成する際は、サーバーとクライアントの両方のコンポーネントが構造化され、最新のC#プラクティスに従い、適切なエラー処理とドキュメントを含むようにしてください。
